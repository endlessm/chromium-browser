{"version":3,"sources":["warning/code-printer.ts"],"names":[],"mappings":"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","file":"code-printer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {SourceRange} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\n\nexport function underlineCode(\n    sourceRange: SourceRange,\n    parsedDocument: ParsedDocument<any, any>,\n    colorizer = (s: string) => s): string|undefined {\n  const relativeRange =\n      parsedDocument.absoluteToRelativeSourceRange(sourceRange);\n  const code = _getRelavantSourceCode(relativeRange, parsedDocument);\n  if (!code) {\n    return undefined;\n  }\n  const outputLines: string[] = [];\n  const lines = code.split('\\n');\n  let lineNum = relativeRange.start.line;\n  for (const line of lines) {\n    outputLines.push(line);\n    outputLines.push(\n        colorizer(getSquiggleUnderline(line, lineNum, relativeRange)));\n    lineNum++;\n  }\n  return outputLines.join('\\n');\n}\n\nfunction _getRelavantSourceCode(\n    relativeRange: SourceRange,\n    parsedDocument: ParsedDocument<any, any>): string|undefined {\n  if (parsedDocument === null) {\n    return;\n  }\n  const startOffset = parsedDocument.sourcePositionToOffset(\n      {column: 0, line: relativeRange.start.line});\n  let endOffset;\n  if (parsedDocument.newlineIndexes.length === relativeRange.end.line) {\n    endOffset = parsedDocument.sourcePositionToOffset(\n        {column: 0, line: relativeRange.end.line + 1});\n  } else {\n    endOffset = parsedDocument.sourcePositionToOffset(\n        {column: -1, line: relativeRange.end.line + 1});\n  }\n\n  return parsedDocument.contents.slice(startOffset, endOffset);\n}\n\nfunction getSquiggleUnderline(\n    lineText: string, lineNum: number, sourceRange: SourceRange) {\n  // We're on a middle line of a multiline range. Squiggle the entire line.\n  if (lineNum !== sourceRange.start.line && lineNum !== sourceRange.end.line) {\n    return '~'.repeat(lineText.length);\n  }\n  // The tricky case. Might be the start of a multiline range, or it might just\n  // be a one-line range.\n  if (lineNum === sourceRange.start.line) {\n    const startColumn = sourceRange.start.column;\n    const endColumn = sourceRange.end.line === sourceRange.start.line ?\n        sourceRange.end.column :\n        lineText.length;\n    const prefix = lineText.slice(0, startColumn).replace(/[^\\t]/g, ' ');\n    if (startColumn === endColumn) {\n      return prefix + '~';  // always draw at least one squiggle\n    }\n    return prefix + '~'.repeat(endColumn - startColumn);\n  }\n\n  // We're on the end line of a multiline range. Just squiggle up to the end\n  // column.\n  return '~'.repeat(sourceRange.end.column);\n}\n"]}