{"version":3,"sources":["scanning/scan.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;;;;;;;;;AAQH,cAEI,QAAc,EAAE,QAA2C;;QAC7D,wEAAwE;QACxE,qEAAqE;QACrE,mEAAmE;QACnE,8DAA8D;QAC9D,+DAA+D;QAE/D,8CAA8C;QAC9C,IAAI,SAAqB,CAAC;QAE1B,8BAA8B;QAC9B,IAAI,eAA8B,CAAC;QAEnC,4BAA4B;QAC5B,IAAI,QAAmB,CAAC;QAExB,gEAAgE;QAChE,IAAI,MAAM,GAAuB,IAAI,CAAC;QAEtC,IAAI,UAAe,CAAC;QAEpB,8CAA8C;QAC9C;YACE,eAAe,GAAG,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,CAAC;gBAC7C,SAAS,GAAG,OAAO,CAAC;YACtB,CAAC,CAAC,CAAC;YACH,QAAQ,GAAG,EAAE,CAAC;YACd,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;QAED,qCAAqC;QACrC;YACE,sEAAsE;YACtE,iBAAiB;YACjB,MAAM,eAAe,GAAG,QAAQ,CAAC;YACjC,MAAM,mBAAmB,GAAG,SAAS,CAAC;YACtC,KAAK,EAAE,CAAC;YAER,IAAI,CAAC;gBACH,QAAQ,CAAC,KAAK,CAAC,eAAe,CAAC,CAAC;YAClC,CAAC;oBAAS,CAAC;gBACT,oDAAoD;gBACpD,mBAAmB,EAAE,CAAC;YACxB,CAAC;QACH,CAAC;QAAA,CAAC;QAEF,kCAAkC;QAClC,eAAe,OAAgB;YAC7B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;YACvB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,MAAM,GAAG,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC,KAAK,CAAC,CAAC,KAAK;oBACvD,UAAU,GAAG,UAAU,IAAI,KAAK,CAAC;gBACnC,CAAC,CAAC,CAAC;YACL,CAAC;YACD,MAAM,CAAC,eAAe,CAAC;QACzB,CAAC;QAAA,CAAC;QAEF,UAAU;QACV,KAAK,EAAE,CAAC;QACR,MAAM,eAAe,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC,CAAC;QAErE,8CAA8C;QAC9C,MAAM,aAAa,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;QAEzD,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC;YACf,MAAM,UAAU,CAAC;QACnB,CAAC;QAED,MAAM,cAAc,GAAG,EAAE,CAAC;QAC1B,MAAM,QAAQ,GAAc,EAAE,CAAC;QAC/B,GAAG,CAAC,CAAC,MAAM,EAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,EAAC,IAAI,aAAa,CAAC,CAAC,CAAC;YACpD,cAAc,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC9B,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;gBACpB,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACtB,CAAC;QACH,CAAC;QAED,MAAM,CAAC,EAAC,QAAQ,EAAE,YAAY,CAAC,cAAc,CAAC,EAAE,QAAQ,EAAC,CAAC;IAC5D,CAAC;CAAA;AAhFD,oBAgFC;AAED,yCACI,IAAoB,EAAE,IAAoB;IAC5C,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC;IAChC,MAAM,MAAM,GAAG,IAAI,CAAC,WAAW,CAAC;IAChC,EAAE,CAAC,CAAC,MAAM,KAAK,MAAM,CAAC,CAAC,CAAC;QACtB,8CAA8C;QAC9C,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IACD,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC;QACnB,mBAAmB;QACnB,MAAM,CAAC,CAAC,CAAC,CAAC;IACZ,CAAC;IACD,EAAE,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,CAAC,CAAC;QACnB,oBAAoB;QACpB,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IACD,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC;IAC/B,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK,CAAC;IAC/B,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,CAAC,CAAC,CAAC;IACZ,CAAC;IACD,EAAE,CAAC,CAAC,SAAS,CAAC,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;QACpC,MAAM,CAAC,CAAC,CAAC;IACX,CAAC;IACD,sCAAsC;IACtC,MAAM,CAAC,SAAS,CAAC,MAAM,GAAG,SAAS,CAAC,MAAM,CAAC;AAC7C,CAAC;AAED,sBACI,iBAAiE;IAEnE,MAAM,WAAW,GAAG,EAAE,CAAC;IACvB,GAAG,CAAC,CAAC,MAAM,QAAQ,IAAI,iBAAiB,CAAC,CAAC,CAAC;QACzC,WAAW,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC,CAAC;IAChC,CAAC;IACD,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,+BAA+B,CAAC,CAAC;AAC3D,CAAC","file":"scan.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {ImmutableArray} from '../model/immutable';\nimport {ScannedFeature, Warning} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\n\nimport {Scanner} from './scanner';\n\nexport async function\nscan<AstNode, Visitor, PDoc extends ParsedDocument<AstNode, Visitor>>(\n    document: PDoc, scanners: Scanner<PDoc, AstNode, Visitor>[]) {\n  // Scanners register a visitor to run via the `visit` callback passed to\n  // `scan()`. We run these visitors in a batch, then pass control back\n  // to the `scan()` methods by resolving a single Promise return for\n  // all calls to visit() in a batch when the visitors have run.\n  // Then we repeat if any visitors have registered new visitors.\n\n  // Resolves Promises returned by visit() calls\n  let batchDone: () => void;\n\n  // Promise returned by visit()\n  let visitorsPromise: Promise<void>;\n\n  // Current batch of visitors\n  let visitors: Visitor[];\n\n  // A Promise that runs the next batch of visitors in a microtask\n  let runner: Promise<void>|null = null;\n\n  let visitError: any;\n\n  // Initializes the current batch running state\n  function setup() {\n    visitorsPromise = new Promise<void>((resolve, _) => {\n      batchDone = resolve;\n    });\n    visitors = [];\n    runner = null;\n  }\n\n  // Runs the current batch of visitors\n  function runVisitors() {\n    // Record the current state so that any new visitors are enqueued into\n    // a fresh batch.\n    const currentVisitors = visitors;\n    const currentDoneCallback = batchDone;\n    setup();\n\n    try {\n      document.visit(currentVisitors);\n    } finally {\n      // Let `scan` continue after calls to visit().then()\n      currentDoneCallback();\n    }\n  };\n\n  // The callback passed to `scan()`\n  function visit(visitor: Visitor) {\n    visitors.push(visitor);\n    if (!runner) {\n      runner = Promise.resolve().then(runVisitors).catch((error) => {\n        visitError = visitError || error;\n      });\n    }\n    return visitorsPromise;\n  };\n\n  // Ok, go!\n  setup();\n  const scannerPromises = scanners.map((f) => f.scan(document, visit));\n\n  // This waits for all `scan()` calls to finish\n  const nestedResults = await Promise.all(scannerPromises);\n\n  if (visitError) {\n    throw visitError;\n  }\n\n  const nestedFeatures = [];\n  const warnings: Warning[] = [];\n  for (const {features, warnings: w} of nestedResults) {\n    nestedFeatures.push(features);\n    if (w !== undefined) {\n      warnings.push(...w);\n    }\n  }\n\n  return {features: sortFeatures(nestedFeatures), warnings};\n}\n\nfunction compareFeaturesBySourceLocation(\n    ent1: ScannedFeature, ent2: ScannedFeature): number {\n  const range1 = ent1.sourceRange;\n  const range2 = ent2.sourceRange;\n  if (range1 === range2) {\n    // Should only be true in the `both null` case\n    return 0;\n  }\n  if (range2 == null) {\n    // ent1 comes first\n    return -1;\n  }\n  if (range1 == null) {\n    // ent1 comes second\n    return 1;\n  }\n  const position1 = range1.start;\n  const position2 = range2.start;\n  if (position1.line < position2.line) {\n    return -1;\n  }\n  if (position1.line > position2.line) {\n    return 1;\n  }\n  // Lines are equal, compare by column.\n  return position1.column - position2.column;\n}\n\nfunction sortFeatures(\n    unorderedFeatures: ImmutableArray<ImmutableArray<ScannedFeature>>):\n    ScannedFeature[] {\n  const allFeatures = [];\n  for (const subArray of unorderedFeatures) {\n    allFeatures.push(...subArray);\n  }\n  return allFeatures.sort(compareFeaturesBySourceLocation);\n}\n"]}