{"version":3,"sources":["core/analyzer.ts"],"names":[],"mappings":"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","file":"analyzer.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/// <reference path=\"../../custom_typings/main.d.ts\" />\n\nimport * as path from 'path';\n\nimport {Analysis, Document, Warning} from '../model/model';\nimport {Parser} from '../parser/parser';\nimport {Scanner} from '../scanning/scanner';\nimport {UrlLoader} from '../url-loader/url-loader';\nimport {UrlResolver} from '../url-loader/url-resolver';\n\nimport {AnalysisContext} from './analysis-context';\n\nexport interface Options {\n  urlLoader: UrlLoader;\n  urlResolver?: UrlResolver;\n  parsers?: Map<string, Parser<any>>;\n  scanners?: ScannerTable;\n  /*\n   * Map from url of an HTML Document to another HTML document it lazily depends\n   * on.\n   */\n  lazyEdges?: LazyEdgeMap;\n\n  // For internal use\n  __contextPromise?: Promise<AnalysisContext>;\n}\n\n/**\n * These are the options available to the `_fork` method.  Currently, only the\n * `urlLoader` override is implemented.\n */\nexport interface ForkOptions { urlLoader?: UrlLoader; }\n\nexport class NoKnownParserError extends Error {};\n\nexport type ScannerTable = Map<string, Scanner<any, any, any>[]>;\nexport type LazyEdgeMap = Map<string, string[]>;\n\n/**\n * A static analyzer for web projects.\n *\n * An Analyzer can load and parse documents of various types, and extract\n * arbitrary information from the documents, and transitively load\n * dependencies. An Analyzer instance is configured with parsers, and scanners\n * which do the actual work of understanding different file types.\n */\nexport class Analyzer {\n  private _analysisComplete: Promise<AnalysisContext>;\n  private readonly _urlResolver: UrlResolver;\n  private readonly _urlLoader: UrlLoader;\n\n  constructor(options: Options) {\n    if (options.__contextPromise) {\n      this._urlLoader = options.urlLoader;\n      this._urlResolver = options.urlResolver!;\n      this._analysisComplete = options.__contextPromise;\n    } else {\n      const context = new AnalysisContext(options);\n      this._urlResolver = context.resolver;\n      this._urlLoader = context.loader;\n      this._analysisComplete = Promise.resolve(context);\n    }\n  }\n\n  /**\n   * Loads, parses and analyzes the root document of a dependency graph and its\n   * transitive dependencies.\n   */\n  async analyze(urls: string[]): Promise<Analysis> {\n    const previousAnalysisComplete = this._analysisComplete;\n    this._analysisComplete = (async() => {\n      const previousContext = await previousAnalysisComplete;\n      return await previousContext.analyze(urls);\n    })();\n    const context = await this._analysisComplete;\n    const results = new Map(urls.map(\n        (url) => [url, context.getDocument(url)] as\n            [string, Document | Warning]));\n    return new Analysis(results);\n  }\n\n  async analyzePackage(): Promise<Analysis> {\n    const previousAnalysisComplete = this._analysisComplete;\n    let _package: Analysis|null = null;\n    this._analysisComplete = (async() => {\n      const previousContext = await previousAnalysisComplete;\n      if (!previousContext.loader.readDirectory) {\n        throw new Error(\n            `This analyzer doesn't support analyzerPackage, ` +\n            `the urlLoader can't list the files in a directory.`);\n      }\n      const allFiles = await previousContext.loader.readDirectory('', true);\n      // TODO(rictic): parameterize this, perhaps with polymer.json.\n      const filesInPackage =\n          allFiles.filter((file) => !Analysis.isExternal(file));\n      const extensions = new Set(previousContext.parsers.keys());\n      const filesWithParsers = filesInPackage.filter(\n          (fn) => extensions.has(path.extname(fn).substring(1)));\n\n      const newContext = await previousContext.analyze(filesWithParsers);\n\n      const documentsOrWarnings = new Map(filesWithParsers.map(\n          (url) => [url, newContext.getDocument(url)] as\n              [string, Document | Warning]));\n      _package = new Analysis(documentsOrWarnings);\n      return newContext;\n    })();\n    await this._analysisComplete;\n    return _package!;\n  }\n\n  /**\n   * Clears all information about the given files from our caches, such that\n   * future calls to analyze() will reload these files if they're needed.\n   *\n   * The analyzer assumes that if this method isn't called with a file's url,\n   * then that file has not changed and does not need to be reloaded.\n   *\n   * @param urls The urls of files which may have changed.\n   */\n  async filesChanged(urls: string[]): Promise<void> {\n    const previousAnalysisComplete = this._analysisComplete;\n    this._analysisComplete = (async() => {\n      const previousContext = await previousAnalysisComplete;\n      return await previousContext.filesChanged(urls);\n    })();\n    await this._analysisComplete;\n  }\n\n  /**\n   * Clear all cached information from this analyzer instance.\n   *\n   * Note: if at all possible, instead tell the analyzer about the specific\n   * files that changed rather than clearing caches like this. Caching provides\n   * large performance gains.\n   */\n  async clearCaches(): Promise<void> {\n    const previousAnalysisComplete = this._analysisComplete;\n    this._analysisComplete = (async() => {\n      const previousContext = await previousAnalysisComplete;\n      return await previousContext.clearCaches();\n    })();\n    await this._analysisComplete;\n  }\n\n  /**\n   * Returns a copy of the analyzer.  If options are given, the AnalysisContext\n   * is also forked and individual properties are overridden by the options.\n   * is forked with the given options.\n   *\n   * When the analysis context is forked, its cache is preserved, so you will\n   * see a mixture of pre-fork and post-fork contents when you analyze with a\n   * forked analyzer.\n   *\n   * Note: this feature is experimental. It may be removed without being\n   *     considered a breaking change, so check for its existence before calling\n   *     it.\n   */\n  _fork(options?: ForkOptions): Analyzer {\n    const contextPromise = (async() => {\n      return options ?\n          (await this._analysisComplete)._fork(undefined, options) :\n          (await this._analysisComplete);\n    })();\n    return new Analyzer({\n      urlLoader: this._urlLoader,\n      urlResolver: this._urlResolver,\n      __contextPromise: contextPromise\n    });\n  }\n\n  /**\n   * Returns `true` if the provided resolved URL can be loaded.  Obeys the\n   * semantics defined by `UrlLoader` and should only be used to check\n   * resolved URLs.\n   */\n  canLoad(resolvedUrl: string): boolean {\n    return this._urlLoader.canLoad(resolvedUrl);\n  }\n\n  /**\n   * Loads the content at the provided resolved URL.  Obeys the semantics\n   * defined by `UrlLoader` and should only be used to attempt to load resolved\n   * URLs.\n   */\n  async load(resolvedUrl: string) {\n    return (await this._analysisComplete).load(resolvedUrl);\n  }\n\n  /**\n   * Returns `true` if the given `url` can be resolved.\n   */\n  canResolveUrl(url: string): boolean {\n    return this._urlResolver.canResolve(url);\n  }\n\n  /**\n   * Resoves `url` to a new location.\n   */\n  resolveUrl(url: string): string {\n    return this._urlResolver.resolve(url);\n  }\n}\n"]}