{"version":3,"sources":["model/analysis.ts"],"names":[],"mappings":"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","file":"analysis.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {Document} from './document';\nimport {Feature} from './feature';\nimport {ImmutableMap, ImmutableSet} from './immutable';\nimport {AnalysisQuery as Query, AnalysisQueryWithKind as QueryWithKind, DocumentQuery, FeatureKind, FeatureKindMap, Queryable} from './queryable';\nimport {Warning} from './warning';\n\n\n// A regexp that matches paths to external code.\n// TODO(rictic): Make this extensible (polymer.json?).\n// Note that we match directories named exactly `build`, but will match any\n// directory name prefixed by `bower_components` or `node_modules`, in order to\n// ignore `polymer install`'s variants, which look like bower_components-foo\nconst MATCHES_EXTERNAL = /(^|\\/)(bower_components|node_modules|build($|\\/))/;\n\n/**\n * Represents a queryable interface over all documents in a package/project.\n *\n * Results of queries will include results from all documents in the package, as\n * well as from external dependencies that are transitively imported by\n * documents in the package.\n */\nexport class Analysis implements Queryable {\n  private readonly _results: ImmutableMap<string, Document|Warning>;\n  private readonly _searchRoots: ImmutableSet<Document>;\n\n  static isExternal(path: string) {\n    return MATCHES_EXTERNAL.test(path);\n  }\n\n  constructor(results: Map<string, Document|Warning>) {\n    workAroundDuplicateJsScriptsBecauseOfHtmlScriptTags(results);\n\n    this._results = results;\n    const documents = Array.from(results.values())\n                          .filter((r) => r instanceof Document) as Document[];\n    const potentialRoots = new Set(documents);\n\n    // We trim down the set of documents as a performance optimization. We only\n    // need a set of documents such that all other documents we're interested in\n    // can be reached from them. That way we'll do less duplicate work when we\n    // query over all documents.\n    for (const doc of potentialRoots) {\n      for (const imprt of doc.getFeatures({kind: 'import', imported: true})) {\n        // When there's cycles we can keep any element of the cycle, so why not\n        // this one.\n        if (imprt.document !== doc) {\n          potentialRoots.delete(imprt.document);\n        }\n      }\n    }\n    this._searchRoots = potentialRoots;\n  }\n\n  getDocument(url: string): Document|Warning|undefined {\n    const result = this._results.get(url);\n    if (result != null) {\n      return result;\n    }\n    const documents =\n        Array\n            .from(this.getFeatures(\n                {kind: 'document', id: url, externalPackages: true}))\n            .filter((d) => !d.isInline);\n    if (documents.length !== 1) {\n      return undefined;\n    }\n    return documents[0]!;\n  }\n\n  /**\n   * Get features in the package.\n   *\n   * Be default this includes features in all documents inside the package,\n   * but you can specify whether to also include features that are outside the\n   * package reachable by documents inside. See the documentation for Query for\n   * more details.\n   *\n   * You can also narrow by feature kind and identifier.\n   */\n  getFeatures<K extends FeatureKind>(query: QueryWithKind<K>):\n      Set<FeatureKindMap[K]>;\n  getFeatures(query?: Query): Set<Feature>;\n  getFeatures(query: Query = {}): Set<Feature> {\n    const result = new Set();\n    const docQuery = this._getDocumentQuery(query);\n    for (const doc of this._searchRoots) {\n      addAll(result, doc.getFeatures(docQuery));\n    }\n    return result;\n  }\n\n  /**\n   * Get all warnings in the project.\n   */\n  getWarnings(options?: Query): Warning[] {\n    const warnings = Array.from(this._results.values())\n                         .filter((r) => !(r instanceof Document)) as Warning[];\n    const result = new Set(warnings);\n    const docQuery = this._getDocumentQuery(options);\n    for (const doc of this._searchRoots) {\n      addAll(result, new Set(doc.getWarnings(docQuery)));\n    }\n    return Array.from(result);\n  }\n\n  private _getDocumentQuery(query: Query = {}): DocumentQuery {\n    return {\n      kind: query.kind,\n      id: query.id,\n      externalPackages: query.externalPackages,\n      imported: true,\n      noLazyImports: query.noLazyImports\n    };\n  }\n}\n\n// TODO(justinfagnani): move to utils\nfunction addAll<T>(set1: Set<T>, set2: Set<T>): Set<T> {\n  for (const val of set2) {\n    set1.add(val);\n  }\n  return set1;\n}\n\n/**\n * So, we have this really terrible hack, whereby we generate a new Document for\n * a js file when it is referenced in an external script tag in an HTML\n * document. We do this so that we can inject an artificial import of the HTML\n * document into the js document, so that the HTML document's dependencies are\n * also dependencies of the js document.\n *\n * This works, but we want to eliminate these duplicate JS Documents from the\n * Analysis before the user sees them.\n *\n * https://github.com/Polymer/polymer-analyzer/issues/615 tracks a better\n * solution for this issue\n */\nfunction workAroundDuplicateJsScriptsBecauseOfHtmlScriptTags(\n    results: Map<string, Document|Warning>) {\n  const documents = Array.from(results.values())\n                        .filter((r) => r instanceof Document) as Document[];\n  // TODO(rictic): handle JS imported via script src from HTML better than\n  //     this.\n  const potentialDuplicates =\n      new Set(documents.filter((r) => r.kinds.has('js-document')));\n  const canonicalOverrides = new Set<Document>();\n  for (const doc of documents) {\n    if (potentialDuplicates.has(doc)) {\n      continue;\n    }\n    for (const potentialDupe of potentialDuplicates) {\n      const potentialCanonicalDocs = doc.getFeatures(\n          {kind: 'js-document', id: potentialDupe.url, imported: true});\n      for (const potentialCanonicalDoc of potentialCanonicalDocs) {\n        if (!potentialCanonicalDoc.isInline) {\n          canonicalOverrides.add(potentialCanonicalDoc);\n        }\n      }\n    }\n  }\n\n  for (const canonicalDoc of canonicalOverrides) {\n    results.set(canonicalDoc.url, canonicalDoc);\n  }\n}\n"]}