{"version":3,"sources":["model/immutable.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG;;AA+CH,qBAA4B,CAAM;IAChC,MAAM,CAAC,CAAC,CAAC;AACX,CAAC;AAFD,kCAEC;AAYD,yBAAgC,CAAM;IACpC,MAAM,CAAC,CAAC,CAAC;AACX,CAAC;AAFD,0CAEC","file":"immutable.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * This is a simple pattern to provide a readonly view of a normal javascript\n * collection. Note that this trades performance for protection. There's nothing\n * stoping a user from mutating one of these data structures, save a warning\n * that the typescript compiler may give them.\n *\n * Other options to consider are facebook's Immutable.js which provides a\n * variety of truely immutable data structures.\n */\n\n\n/** A zero-overhead immutable view of an array. */\nexport declare interface ImmutableArray<V> {\n  readonly [index: number]: V|undefined;\n  readonly length: number;\n  slice(left?: number, right?: number): Array<V>;\n  map<U>(f: (v: V, idx: number) => U): Array<U>;\n  forEach(f: (v: V, idx: number) => void): void;\n  concat(...arrs: V[][]): Array<V>;\n  [Symbol.iterator](): Iterator<V>;\n}\n\n/** A zero-overhead immutable view of a set. */\nexport declare interface ImmutableSet<V> {\n  readonly size: number;\n  has(candidate: V): boolean;\n  values(): Iterable<V>;\n  [Symbol.iterator](): Iterator<V>;\n}\n\n/** A zero-overhead immutable view of a map. */\nexport declare interface ImmutableMap<K, V> {\n  readonly size: number;\n  has(candidate: K): boolean;\n  get(key: K): V|undefined;\n  keys(): Iterable<K>;\n  values(): Iterable<V>;\n  entries(): Iterable<[K, V]>;\n  [Symbol.iterator](): Iterator<[K, V]>;\n}\n\nexport function asImmutable<V>(array: Array<V>): ImmutableArray<V>;\nexport function asImmutable<V>(set: Set<V>): ImmutableSet<V>;\nexport function asImmutable<K, V>(map: Map<K, V>): ImmutableMap<K, V>;\nexport function asImmutable<O extends object>(object: O): Readonly<O>;\nexport function asImmutable(x: any) {\n  return x;\n}\n\n/**\n * Take care, this function is inherently unsafe.\n *\n * You're taking a data structure that has been declare as immutable and getting\n * a mutable reference to it.\n */\nexport function unsafeAsMutable<V>(array: ImmutableArray<V>): Array<V>;\nexport function unsafeAsMutable<V>(set: ImmutableSet<V>): Set<V>;\nexport function unsafeAsMutable<K, V>(map: ImmutableMap<K, V>): Map<K, V>;\nexport function unsafeAsMutable<O extends object>(object: Readonly<O>): O;\nexport function unsafeAsMutable(x: any) {\n  return x;\n}\n"]}