"use strict";
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
Object.defineProperty(exports, "__esModule", { value: true });
const dom5 = require("dom5");
const util = require("util");
const jsdoc = require("../javascript/jsdoc");
const document_1 = require("./document");
const immutable_1 = require("./immutable");
/**
 * Represents an inline document, usually a <script> or <style> tag in an HTML
 * document.
 *
 * @template N The AST node type
 */
class ScannedInlineDocument {
    constructor(type, contents, locationOffset, attachedComment, sourceRange, ast) {
        this.warnings = [];
        this.type = type;
        this.contents = contents;
        this.locationOffset = locationOffset;
        this.attachedComment = attachedComment;
        this.sourceRange = sourceRange;
        this.astNode = ast;
    }
    resolve(document) {
        if (!this.scannedDocument) {
            // Parse error on the inline document.
            return;
        }
        const inlineDocument = new InlineDocument(this.scannedDocument, document);
        inlineDocument.resolve();
        return inlineDocument;
    }
}
exports.ScannedInlineDocument = ScannedInlineDocument;
class InlineDocument extends document_1.Document {
    constructor(base, containerDocument) {
        super(base, containerDocument._analysisContext);
        immutable_1.unsafeAsMutable(this.kinds).add('inline-document');
        this._addFeature(containerDocument);
    }
}
exports.InlineDocument = InlineDocument;
function getAttachedCommentText(node) {
    // When the element is defined in a document fragment with a structure of
    // imports -> comment explaining the element -> then its dom-module, the
    // comment will be attached to <head>, rather than being a sibling to the
    // <dom-module>, thus the need to walk up and previous so aggressively.
    const parentComments = dom5.nodeWalkAllPrior(node, dom5.isCommentNode);
    const comment = (parentComments[0] ? parentComments[0]['data'] : undefined);
    if (!comment || /@license/.test(comment)) {
        return;
    }
    return jsdoc.unindent(comment).trim();
}
exports.getAttachedCommentText = getAttachedCommentText;
function isLocationInfo(loc) {
    return 'line' in loc;
}
function getLocationOffsetOfStartOfTextContent(node) {
    const childNodes = node.childNodes || [];
    const firstChildNodeWithLocation = childNodes.find((n) => !!n.__location);
    const bestLocation = firstChildNodeWithLocation ?
        firstChildNodeWithLocation.__location :
        node.__location;
    if (!bestLocation) {
        throw new Error(`Couldn't extract a location offset from HTML node: ` +
            `${util.inspect(node)}`);
    }
    if (isLocationInfo(bestLocation)) {
        return { line: bestLocation.line - 1, col: bestLocation.col - 1 };
    }
    else {
        return {
            line: bestLocation.startTag.line - 1,
            col: bestLocation.startTag.endOffset - 1,
        };
    }
}
exports.getLocationOffsetOfStartOfTextContent = getLocationOffsetOfStartOfTextContent;

//# sourceMappingURL=inline-document.js.map
