{"version":3,"sources":["analysis-format/analysis-format.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;GAYG","file":"analysis-format.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The global namespace of features contained in an analysis.\n *\n * Top-level members are unnamespaced, everything else is contained\n * in a namespace. Often an analysis will contain only one namespace at\n * the root.\n */\nexport interface Analysis {\n  schema_version: string;\n\n  // TODO(rictic): once this schema has stabilized, put the json file somewhere\n  // and reference it like:\n  // $schema: 'http://polymer-project.org/schema/v1/analysis.json';\n\n  /** All elements found. */\n  elements?: Element[];\n  /** All toplevel functions found. */\n  functions?: Function[];\n  /** All element mixins found. */\n  mixins?: ElementMixin[];\n  /** All toplevel namespaces found. */\n  namespaces?: Namespace[];\n  /**\n   * All toplevel classes found that were not covered by one of the other types.\n   *\n   * e.g. classes that are elements are only found in `elements`\n   */\n  classes?: Class[];\n\n  /**\n   * An extension point for framework-specific metadata, as well as any\n   * metadata not yet standardized here such as what polyfills are needed,\n   * behaviors and mixins used, the framework that the package was written in,\n   * tags/categories, framework config files, etc.\n   *\n   * Framework-specific metadata should be put into a sub-object with the name\n   * of that framework.\n   */\n  metadata?: any;\n}\n\n/**\n * The base interface, holding properties common to many nodes.\n */\nexport interface Feature {\n  /** Where this feature is defined in source code. */\n  sourceRange?: SourceRange;\n\n  /**\n   * An extension point for framework-specific metadata, as well as any\n   * metadata not yet standardized here such as what polyfills are needed,\n   * behaviors and mixins used, the framework that the element was written in,\n   * tags/categories, links to specs that the element implements, etc.\n   *\n   * Framework-specific metadata should be put into a sub-object with the name\n   * of that framework.\n   */\n  metadata?: any;\n}\n\nexport interface SourceRange {\n  /**\n   * Path to the file containing the definition of the feature,\n   * relative to the parent feature, or the package if the feature has no parent\n   * (e.g. elements).\n   *\n   * If blank, the feature is defined in the same file as its parent.\n   */\n  file?: string;\n  /* The start of the feature. */\n  start: Position;\n  /* The end of the feature. */\n  end: Position;\n}\n\nexport interface Position {\n  /** Line number, starting from zero. */\n  line: number;\n  /** Column offset within the line, starting from zero. */\n  column: number;\n}\n\nexport type Privacy = 'public' | 'private' | 'protected';\n\nexport interface Function extends Feature {\n  /**\n   * The globally accessible property-path of the namespace. e.q. `Polymer.dom`\n   */\n  name: string;\n\n  /** A markdown description for the namespace. */\n  description?: string;\n\n  summary?: string;\n  params?: {name: string, type?: string}[];\n  return?: {type?: string, desc: string};\n  privacy: Privacy;\n}\n\nexport interface Namespace extends Feature {\n  /**\n   * The globally accessible property-path of the namespace. e.q. `Polymer.dom`\n   */\n  name: string;\n\n  /** A markdown description for the namespace. */\n  description?: string;\n\n  /** A markdown summary for the namespace. */\n  summary?: string;\n\n  elements?: Element[];\n  functions?: Function[];\n  mixins?: ElementMixin[];\n  namespaces?: Namespace[];\n  classes?: Class[];\n}\n\nexport interface Class extends Feature {\n  /** The name of the class. */\n  name?: string;\n\n  /**\n   * The path, relative to the base directory of the package.\n   *\n   * e.g. `paper-input.html` or `app-toolbar/app-toolbar.html` (given that\n   * app-toolbar lives in the app-layout package).\n   */\n  path: string;\n\n  /** A markdown description. */\n  description: string;\n\n  /** A markdown summary. */\n  summary: string;\n\n  /**\n   * Paths, relative to the base directory of the package, to demo pages for\n   * this feauture.\n   *\n   * e.g. `[{url: 'demos/index.html', description: 'How it works'}, ...]`\n   */\n  demos: Demo[];\n\n  /** Names of mixins applied.  */\n  mixins?: string[];\n\n  /** The properties that this feature has. */\n  properties?: Property[];\n\n  /** The instance methods that this feature has. */\n  methods?: Method[];\n\n  /** The static, class-level methods that this feature has. */\n  staticMethods?: Method[];\n\n  privacy: Privacy;\n\n  /**\n   * The class, if any, that this class extends.\n   */\n  superclass?: string;\n}\n\nexport interface ElementLike extends Class {\n  /** The attributes that this element is known to understand. */\n  attributes?: Attribute[];\n\n  /** The events that this element fires. */\n  events?: Event[];\n\n  /** The shadow dom content slots that this element accepts. */\n  'slots': Slot[];  // this formatting is strange, yes\n\n  /** Information useful for styling the element and its children. */\n  styling: {\n\n    /** CSS selectors that the element recognizes on itself for styling. */\n    selectors: {\n      /** The CSS selector. e.g. `.bright`, `[height=5]`, `[cascade]`. */\n      value: string;\n      /**\n       * A markdown description of the effect of this selector matching\n       * on the element.\n       */\n      description: string;\n    }[];\n\n    /** CSS Variables that the element understands. */\n    cssVariables: {\n\n      /** The name of the variable. e.g. `--header-color`, `--my-element-size`*/\n      name: string;\n\n      /** The type of the variable. Advisory. e.g. `color`, `size` */\n      type?: string;\n\n      /** A markdown description of the variable. */\n      description?: string;\n\n      /**\n       * A markdown description of how the element will fallback if the variable\n       * isn't defined.\n       */\n      fallbackBehavior?: string;\n    }[];\n\n    /** If true, the element must be given an explicit size by its context. */\n    needsExplicitSize?: boolean;\n\n    // Would be nice to document the default styling a bit here, whether it's\n    // display: block or inline or whatever.\n  };\n}\n\nexport interface Element extends ElementLike {\n  /** The tagname that the element registers itself as. e.g. `paper-input` */\n  tagname?: string;\n\n  /**\n   * The class name for this element.\n   *\n   * e.g. `MyElement`, `Polymer.PaperInput`\n   */\n  name?: string;\n\n  /**\n   * The tagname that the element extends, if any. The value of the `extends`\n   * option that's passed into `customElements.define`.\n   *\n   * e.g. `input`, `paper-button`, `my-super-element`\n   */\n  extends?: string;\n\n  /**\n   * The class that this element extends.\n   *\n   * This is non-optional, as every custom element must have HTMLElement in\n   * its prototype change.\n   *\n   * e.g. `HTMLElement`, `HTMLInputElement`, `MyNamespace.MyBaseElement`\n   */\n  superclass: string;\n}\n\nexport interface ElementMixin extends ElementLike {  //\n  /**\n   * The name for this mixin.\n   *\n   * e.g. `MyMixin`, `Polymer.PaperInputMixin`\n   */\n  name: string;\n}\n\nexport interface Attribute extends Feature {\n  /** The name of the attribute. e.g. `value`, `icon`, `should-collapse`. */\n  name: string;\n\n  /** A markdown description for the attribute. */\n  description?: string;\n\n  /**\n   * The type that the attribute will be serialized/deserialized as.\n   *\n   * e.g. `string`, `number`, `boolean`, `RegExp`, `Array`, `Object`.\n   */\n  type?: string;\n\n  /**\n   * The default value of the attribute, if any.\n   *\n   * As attributes are always strings, this is the actual value, not a human\n   * readable description.\n   */\n  defaultValue?: string;\n\n  /** The identifier of the class or mixin that declared this property. */\n  inheritedFrom?: string;\n\n  // We need some way of representing that this attribute is associated with a\n  // property. TBD.\n}\n\nexport interface Property extends Feature {\n  /** The name of the property. e.g. `value`, `icon`, `shouldCollapse`. */\n  name: string;\n\n  /** A markdown description of the property. */\n  description: string;\n\n  /**\n   * The javascript type of the property.\n   *\n   * There's no standard here. Common choices are closure compiler syntax\n   * and typescript syntax.\n   */\n  type: string;\n\n  /**\n   * A string representation of the default value. Intended only to be human\n   * readable, so may be a description, an identifier name, etc.\n   */\n  defaultValue?: string;\n\n  /** Nested subproperties hanging off of this property. */\n  properties?: Property[];\n\n  privacy: Privacy;\n\n  /** The identifier of the class or mixin that declared this property. */\n  inheritedFrom?: string;\n}\n\nexport interface Method extends Feature {\n  /** The name of the property. e.g. `value`, `icon`, `shouldCollapse`. */\n  name: string;\n\n  /** A markdown description of the property. */\n  description: string;\n\n  /**\n   * An array of data objects describing the method signature. This data may be\n   * incomplete. For example, only argument names can be detected from an\n   * undocumented JavaScript function. Argument types can only be read from\n   * associated JSDoc via @param tags\n   */\n  params?: Parameter[];\n\n  /**\n   * Data describing the method return type. This data may be incomplete.\n   * For example, the return type can be detected from a documented JavaScript\n   * function with associated JSDoc and a @return tag.\n   */\n  return?: {type?: string, desc?: string};\n\n  privacy: Privacy;\n\n  /** The identifier of the class or mixin that declared this property. */\n  inheritedFrom?: string;\n}\n\nexport interface Parameter {\n  name: string;\n  type?: string;\n  description?: string;\n}\n\nexport interface Event extends Feature {\n  /** The name of the event. */\n  name: string;\n\n  /** A markdown description of the event. */\n  description: string;\n  /**\n   * The type of the event object that's fired.\n   *\n   * e.g. `Event`, `CustomEvent`, `KeyboardEvent`, `MyCustomEvent`.\n   */\n  type: string;\n\n  /** Information about the `detail` field of the event. */\n  detail?: {properties: Property[]};\n\n  /** The identifier of the class or mixin that declared this property. */\n  inheritedFrom?: string;\n\n  // Should we have a way of associating an event with an attribute or a\n  // property?\n}\n\nexport interface Slot extends Feature {\n  /** The name of the slot. e.g. `banner`, `body`, `tooltipContents` */\n  name: string;\n\n  /** A markdown description of the slot. */\n  description: string;\n\n  // Something about fallback perhaps?\n}\n\nexport interface Demo {\n  /** A markdown description of the demo. */\n  description?: string;\n\n  /** Relative URL of the demo. */\n  url: string;\n}\n"]}