{"version":3,"sources":["javascript/ast-value.ts"],"names":[],"mappings":"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","file":"ast-value.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as estree from 'estree';\n\nimport {LiteralObj, LiteralValue} from '../model/model';\nimport * as jsdoc from './jsdoc';\n\n/**\n * Converts an ast literal to its underlying valie.\n */\nfunction literalToValue(literal: estree.Literal): LiteralValue {\n  return literal.value;\n}\n\n/**\n * Early evaluates a unary expression.\n */\nfunction unaryToValue(unary: estree.UnaryExpression): LiteralValue {\n  const operand = expressionToValue(unary.argument);\n  switch (unary.operator) {\n    case '!':\n      return !(operand as any);\n    case '-':\n      return -(operand as any);\n    case '+':\n      return +(operand as any);\n    case '~':\n      return ~(operand as any);\n    case 'typeof':\n      return typeof operand;\n    case 'void':\n      return void operand;\n    case 'delete':\n      return undefined;\n    default:\n      const never: never = unary.operator;\n      throw new Error(`Unknown unary operator found: ${never}`);\n  }\n}\n\n/**\n * Try to evaluate function bodies.\n */\nfunction functionDeclarationToValue(fn: estree.FunctionDeclaration):\n    LiteralValue {\n  if (fn.body.type === 'BlockStatement') {\n    return blockStatementToValue(fn.body);\n  }\n}\n\nfunction functionExpressionToValue(fn: estree.FunctionExpression):\n    LiteralValue {\n  if (fn.body.type === 'BlockStatement') {\n    return blockStatementToValue(fn.body);\n  }\n}\n\nfunction arrowFunctionExpressionToValue(fn: estree.ArrowFunctionExpression):\n    LiteralValue {\n  if (fn.body.type === 'BlockStatement') {\n    return blockStatementToValue(fn.body);\n  } else {\n    return expressionToValue(fn.body);\n  }\n}\n\n/**\n * Block statement: find last return statement, and return its value\n */\nfunction blockStatementToValue(block: estree.BlockStatement): LiteralValue {\n  for (let i = block.body.length - 1; i >= 0; i--) {\n    const body = block.body[i];\n    if (body.type === 'ReturnStatement') {\n      return returnStatementToValue(body);\n    }\n  }\n}\n\n/**\n * Evaluates return's argument\n */\nfunction returnStatementToValue(ret: estree.ReturnStatement): LiteralValue {\n  return expressionToValue(\n      ret.argument || {type: 'Literal', value: null, raw: 'null'});\n}\n\n/**\n * Evaluate array expression\n */\nfunction arrayExpressionToValue(arry: estree.ArrayExpression): LiteralValue {\n  const value: LiteralValue[] = [];\n  for (let i = 0; i < arry.elements.length; i++) {\n    const v = expressionToValue(arry.elements[i]);\n    if (v === undefined) {\n      continue;\n    }\n    value.push(v);\n  }\n  return value;\n}\n\n/**\n * Evaluate object expression\n */\nfunction objectExpressionToValue(obj: estree.ObjectExpression): LiteralValue {\n  const evaluatedObjectExpression: LiteralObj = {};\n  for (const prop of obj.properties) {\n    if (prop.key.type !== 'Literal') {\n      return;\n    }\n    const evaluatedKey = '' + literalToValue(prop.key);\n    const evaluatedValue = expressionToValue(prop.value);\n    if (evaluatedValue === undefined) {\n      return;\n    }\n    evaluatedObjectExpression[evaluatedKey] = evaluatedValue;\n  }\n  return evaluatedObjectExpression;\n}\n\n/**\n * Binary expressions, like 5 + 5\n */\nfunction binaryExpressionToValue(member: estree.BinaryExpression):\n    (number|string|undefined) {\n  const left = expressionToValue(member.left);\n  const right = expressionToValue(member.right);\n  if (left == null || right == null) {\n    return;\n  }\n  if (member.operator === '+') {\n    // We need to cast to `any` here because, while it's usually not the right\n    // thing to do to use '+' on two values of a mix of types because it's\n    // unpredictable, that is what the original code we're evaluating does.\n    return <any>left + right;\n  }\n  return;\n}\n\n/**\n * Tries to get the value of an expression. Returns undefined on failure.\n */\nexport function expressionToValue(valueExpression: estree.Node): LiteralValue {\n  switch (valueExpression.type) {\n    case 'Literal':\n      return literalToValue(valueExpression);\n    case 'UnaryExpression':\n      return unaryToValue(valueExpression);\n    case 'FunctionDeclaration':\n      return functionDeclarationToValue(valueExpression);\n    case 'FunctionExpression':\n      return functionExpressionToValue(valueExpression);\n    case 'ArrowFunctionExpression':\n      return arrowFunctionExpressionToValue(valueExpression);\n    case 'ArrayExpression':\n      return arrayExpressionToValue(valueExpression);\n    case 'ObjectExpression':\n      return objectExpressionToValue(valueExpression);\n    case 'BinaryExpression':\n      return binaryExpressionToValue(valueExpression);\n    default:\n      return;\n  }\n}\n\n/**\n * Extracts the name of the identifier or `.` separated chain of identifiers.\n *\n * Returns undefined if the given node isn't a simple identifier or chain of\n * simple identifiers.\n */\nexport function getIdentifierName(node: estree.Node): string|undefined {\n  if (node.type === 'Identifier') {\n    return node.name;\n  }\n  if (node.type === 'MemberExpression') {\n    const object = getIdentifierName(node.object);\n    let property;\n    if (node.computed) {\n      property = expressionToValue(node.property);\n    } else {\n      property = getIdentifierName(node.property);\n    }\n    if (object != null && property != null) {\n      return `${object}.${property}`;\n    }\n  }\n}\n\n/**\n * Formats the given identifier name under a namespace, if one is mentioned in\n * the commentedNode's comment. Otherwise, name is returned.\n */\nexport function getNamespacedIdentifier(\n    name: string, docs?: jsdoc.Annotation): string {\n  if (!docs) {\n    return name;\n  }\n  const memberofTag = jsdoc.getTag(docs, 'memberof');\n  const namespace = memberofTag && memberofTag.description;\n  if (namespace) {\n    const rightMostIdentifierName = name.substring(name.lastIndexOf('.') + 1);\n    return namespace + '.' + rightMostIdentifierName;\n  } else {\n    return name;\n  }\n}\n\n\nexport const CANT_CONVERT = 'UNKNOWN';\n"]}