{"version":3,"sources":["javascript/javascript-document.ts"],"names":[],"mappings":"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","file":"javascript-document.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as escodegen from 'escodegen';\nimport {traverse, VisitorOption} from 'estraverse';\nimport {Node, Program} from 'estree';\n\nimport {SourceRange} from '../model/model';\nimport {Options as ParsedDocumentOptions, ParsedDocument, StringifyOptions} from '../parser/document';\n\nimport {Visitor, VisitResult} from './estree-visitor';\n\nexport {Visitor} from './estree-visitor';\n\n/**\n * estree.Node#type is one of around a hundred string literals. We don't have\n * a direct reference to the type that represents any of those string literals\n * though. We can get a reference by taking a Node and using the `typeof`\n * operator, and it doesn't need to be a real Node as all of this happens at\n * analysis time, and nothing happens at runtime.\n */\nconst __exampleNode: Node = <any>null;\ntype EstreeType = typeof __exampleNode.type;\ninterface SkipRecord {\n  type: EstreeType;\n  depth: number;\n}\n\nexport interface Options extends ParsedDocumentOptions<Program> {\n  parsedAsSourceType: 'script'|'module';\n}\n\nexport class JavaScriptDocument extends ParsedDocument<Node, Visitor> {\n  type = 'js';\n  private visitorSkips = new Map<Visitor, SkipRecord>();\n  ast: Program;\n\n  /**\n   * How the js document was parsed. If 'module' then the source code is\n   * definitely an ES6 module, as it has imports or exports. If 'script' then\n   * it may be an ES6 module with no imports or exports, or it may be a\n   * script.\n   */\n  parsedAsSourceType: 'script'|'module';\n\n  constructor(from: Options) {\n    super(from);\n    this.parsedAsSourceType = from.parsedAsSourceType;\n  }\n\n  visit(visitors: Visitor[]) {\n    /**\n     * Applies all visiting callbacks from `visitors`.\n     */\n    const applyScanners = (callbackName: string, node: Node, parent: Node) => {\n      for (const visitor of visitors) {\n        if (_shouldSkip(visitor, callbackName, node.type)) {\n          continue;\n        }\n        if (callbackName in visitor) {\n          // TODO(rictic): is there a maintainable way to enforce the\n          //     mapping between callback names and the types of the first\n          //     arg?\n          const result: VisitResult =\n              (visitor as any)[callbackName](node, parent);\n          if (result) {\n            handleVisitorResult(result, callbackName, visitor, node.type);\n          }\n        }\n      }\n    };\n\n    // a visitor to break early, or to skip a subtree of the AST. We need to\n    // track this ourselves because we're running all the visitors at once.\n    const _shouldSkip =\n        (visitor: Visitor,\n         callbackName: string,\n         nodeType: typeof __exampleNode.type) => {\n          const skipRecord = this.visitorSkips.get(visitor);\n          if (!skipRecord) {\n            return false;\n          }\n          if (callbackName === `enter${nodeType}`) {\n            skipRecord.depth += 1;\n            return true;\n          } else if (callbackName === `leave${nodeType}`) {\n            skipRecord.depth -= 1;\n            if (skipRecord.depth === 0) {\n              this.visitorSkips.delete(visitor);\n              // Note that we don't `continue` here. This is deliberate so that\n              // we call the leave handler for the node where we started\n              // skipping.\n            } else {\n              return true;\n            }\n          } else {\n            return true;\n          }\n        };\n\n    const handleVisitorResult =\n        (visitorOption: VisitorOption,\n         callbackName: string,\n         visitor: Visitor,\n         nodeType: typeof __exampleNode.type) => {\n          switch (visitorOption) {\n            case VisitorOption.Remove:\n              throw new Error(\n                  `estraverse.VisitorOption.Remove not ` +\n                  `supported by JavascriptDocument`);\n            case VisitorOption.Break:\n              visitors = visitors.filter((v) => v !== visitor);\n              break;\n            case VisitorOption.Skip:\n              if (callbackName.startsWith('leave')) {\n                throw new Error(\n                    `estraverse.VisitorOption.Skip was returned from ` +\n                    `${callbackName} but it's not supported in a leave method`);\n              }\n              this.visitorSkips.set(visitor, {type: nodeType, depth: 1});\n              break;\n          }\n        };\n\n    traverse(this.ast, {\n      enter(node, parent) {\n        applyScanners(`enter${node.type}`, node, parent);\n      },\n      leave(node, parent) {\n        applyScanners(`leave${node.type}`, node, parent);\n      },\n      fallback: 'iteration',\n    });\n  }\n\n  forEachNode(callback: (node: Node) => void) {\n    traverse(this.ast, {\n      enter(node, _parent) {\n        callback(node);\n      },\n      fallback: 'iteration',\n    });\n  }\n\n  protected _sourceRangeForNode(node: Node): SourceRange|undefined {\n    if (!node || !node.loc) {\n      return;\n    }\n    return {\n      file: this.url,\n      // Note: estree uses 1-indexed lines, but SourceRange uses 0 indexed.\n      start: {line: (node.loc.start.line - 1), column: node.loc.start.column},\n      end: {line: (node.loc.end.line - 1), column: node.loc.end.column}\n    };\n  }\n\n  stringify(options: StringifyOptions) {\n    options = options || {};\n    const formatOptions = {\n      comment: true,\n      format: {indent: {style: '  ', adjustMultilineComment: true, base: 0}}\n    };\n    if (options.indent != null) {\n      formatOptions.format.indent.base = options.indent;\n    }\n\n    return escodegen.generate(this.ast, formatOptions) + '\\n';\n  }\n}\n"]}