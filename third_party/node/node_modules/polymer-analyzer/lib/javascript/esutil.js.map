{"version":3,"sources":["javascript/esutil.ts"],"names":[],"mappings":"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","file":"esutil.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as doctrine from 'doctrine';\nimport * as escodegen from 'escodegen';\n\nimport * as estraverse from 'estraverse';\nimport * as estree from 'estree';\n\nimport {ScannedMethod} from '../index';\nimport {ImmutableSet} from '../model/immutable';\nimport {Privacy} from '../model/model';\nimport {ScannedEvent, Severity, SourceRange, Warning, WarningCarryingException} from '../model/model';\nimport {ParsedDocument} from '../parser/document';\nimport * as docs from '../polymer/docs';\nimport {annotateEvent} from '../polymer/docs';\n\nimport {JavaScriptDocument} from './javascript-document';\nimport * as jsdoc from './jsdoc';\n\n/**\n * Returns whether an Espree node matches a particular object path.\n *\n * e.g. you have a MemberExpression node, and want to see whether it represents\n * `Foo.Bar.Baz`:\n *    matchesCallExpressio\n    (node, ['Foo', 'Bar', 'Baz'])\n *\n * @param {ESTree.Node} expression The Espree node to match against.\n * @param {Array<string>} path The path to look for.\n */\nexport function matchesCallExpression(\n    expression: estree.MemberExpression, path: string[]): boolean {\n  if (!expression.property || !expression.object) {\n    return false;\n  }\n  console.assert(path.length >= 2);\n\n  if (expression.property.type !== 'Identifier') {\n    return false;\n  }\n  // Unravel backwards, make sure properties match each step of the way.\n  if (expression.property.name !== path[path.length - 1]) {\n    return false;\n  }\n  // We've got ourselves a final member expression.\n  if (path.length === 2 && expression.object.type === 'Identifier') {\n    return expression.object.name === path[0];\n  }\n  // Nested expressions.\n  if (path.length > 2 && expression.object.type === 'MemberExpression') {\n    return matchesCallExpression(\n        expression.object, path.slice(0, path.length - 1));\n  }\n\n  return false;\n}\n\n/**\n * @param {Node} key The node representing an object key or expression.\n * @return {string} The name of that key.\n */\nexport function objectKeyToString(key: estree.Node): string|undefined {\n  if (key.type === 'Identifier') {\n    return key.name;\n  }\n  if (key.type === 'Literal') {\n    return '' + key.value;\n  }\n  if (key.type === 'MemberExpression') {\n    return objectKeyToString(key.object) + '.' +\n        objectKeyToString(key.property);\n  }\n  return undefined;\n}\n\nexport const CLOSURE_CONSTRUCTOR_MAP = new Map(\n    [['Boolean', 'boolean'], ['Number', 'number'], ['String', 'string']]);\n\n/**\n * AST expression -> Closure type.\n *\n * Accepts literal values, and native constructors.\n *\n * @param {Node} node An Espree expression node.\n * @return {string} The type of that expression, in Closure terms.\n */\nexport function closureType(\n    node: estree.Node,\n    sourceRange: SourceRange,\n    document: ParsedDocument<any, any>): string {\n  if (node.type.match(/Expression$/)) {\n    return node.type.substr(0, node.type.length - 10);\n  } else if (node.type === 'Literal') {\n    return typeof node.value;\n  } else if (node.type === 'Identifier') {\n    return CLOSURE_CONSTRUCTOR_MAP.get(node.name) || node.name;\n  } else {\n    throw new WarningCarryingException(new Warning({\n      code: 'no-closure-type',\n      message: `Unable to determine closure type for expression of type ` +\n          `${node.type}`,\n      severity: Severity.WARNING, sourceRange,\n      parsedDocument: document,\n    }));\n  }\n}\n\nexport function getAttachedComment(node: estree.Node): string|undefined {\n  const comments = getLeadingComments(node) || [];\n  return comments && comments[comments.length - 1];\n}\n\n/**\n * Returns all comments from a tree defined with @event.\n */\nexport function getEventComments(node: estree.Node): Map<string, ScannedEvent> {\n  const eventComments = new Set<string>();\n  estraverse.traverse(node, {\n    enter: (node: estree.Node) => {\n      (node.leadingComments || [])\n          .concat(node.trailingComments || [])\n          .map((commentAST) => commentAST.value)\n          .filter((comment) => comment.indexOf('@event') !== -1)\n          .forEach((comment) => eventComments.add(comment));\n    }\n  });\n  const events = [...eventComments]\n                     .map(\n                         (comment) => annotateEvent(jsdoc.parseJsdoc(\n                             jsdoc.removeLeadingAsterisks(comment).trim())))\n                     .filter((ev) => !!ev)\n                     .sort((ev1, ev2) => ev1.name.localeCompare(ev2.name));\n  return new Map(events.map((e) => [e.name, e] as [string, ScannedEvent]));\n}\n\nfunction getLeadingComments(node: estree.Node): string[]|undefined {\n  if (!node) {\n    return;\n  }\n  const comments = [];\n  for (const comment of node.leadingComments || []) {\n    // Espree says any comment that immediately precedes a node is \"leading\",\n    // but we want to be stricter and require them to be touching. If we don't\n    // have locations for some reason, err on the side of including the\n    // comment.\n    if (!node.loc || !comment.loc ||\n        node.loc.start.line - comment.loc.end.line < 2) {\n      comments.push(comment.value);\n    }\n  }\n  return comments.length ? comments : undefined;\n}\n\nexport function getPropertyValue(\n    node: estree.ObjectExpression, name: string): estree.Node|undefined {\n  const properties = node.properties;\n  for (const property of properties) {\n    if (objectKeyToString(property.key) === name) {\n      return property.value;\n    }\n  }\n}\n\nexport function isFunctionType(node: estree.Node): node is estree.Function {\n  return node.type === 'ArrowFunctionExpression' ||\n      node.type === 'FunctionExpression' || node.type === 'FunctionDeclaration';\n}\n\n\n/**\n * Create a ScannedMethod object from an estree Property AST node.\n */\nexport function toScannedMethod(\n    node: estree.Property|estree.MethodDefinition,\n    sourceRange: SourceRange,\n    document: ParsedDocument<any, any>): ScannedMethod {\n  const parsedJsdoc = jsdoc.parseJsdoc(getAttachedComment(node) || '');\n  const description = parsedJsdoc.description.trim();\n  const maybeName = objectKeyToString(node.key);\n\n  const warnings: Warning[] = [];\n  if (!maybeName) {\n    warnings.push(new Warning({\n      code: 'unknown-method-name',\n      message: `Could not determine name of method from expression of type: ` +\n          `${node.key.type}`,\n      sourceRange: sourceRange,\n      severity: Severity.INFO,\n      parsedDocument: document\n    }));\n  }\n  let type = closureType(node.value, sourceRange, document);\n  const typeTag = jsdoc.getTag(parsedJsdoc, 'type');\n  if (typeTag) {\n    type = doctrine.type.stringify(typeTag.type!) || type;\n  }\n  const name = maybeName || '';\n  const scannedMethod: ScannedMethod = {\n    name,\n    type,\n    description,\n    sourceRange,\n    warnings,\n    astNode: node,\n    jsdoc: parsedJsdoc,\n    privacy: getOrInferPrivacy(name, parsedJsdoc)\n  };\n\n  const value = node.value;\n  if (value.type === 'FunctionExpression' ||\n      value.type === 'ArrowFunctionExpression') {\n    const paramTags = new Map<string, doctrine.Tag>();\n    if (scannedMethod.jsdoc) {\n      for (const tag of (scannedMethod.jsdoc.tags || [])) {\n        if (tag.title === 'param' && tag.name) {\n          paramTags.set(tag.name, tag);\n\n        } else if (tag.title === 'return' || tag.title === 'returns') {\n          scannedMethod.return = {};\n          if (tag.type) {\n            scannedMethod.return.type = doctrine.type.stringify(tag.type!);\n          }\n          if (tag.description) {\n            scannedMethod.return.desc = tag.description;\n          }\n        }\n      }\n    }\n\n    scannedMethod.params = (value.params || []).map((nodeParam) => {\n      let type = undefined;\n      let description = undefined;\n      // With ES6 we can have a lot of param patterns. Best to leave the\n      // formatting to escodegen.\n      const name = escodegen.generate(nodeParam);\n      const tag = paramTags.get(name);\n      if (tag) {\n        if (tag.type) {\n          type = doctrine.type.stringify(tag.type);\n        }\n        if (tag.description) {\n          description = tag.description;\n        }\n      }\n      return {name, type, description};\n    });\n  }\n\n  return scannedMethod;\n}\n\n\nexport function getOrInferPrivacy(\n    name: string,\n    annotation: jsdoc.Annotation|undefined,\n    defaultPrivacy: Privacy = 'public'): Privacy {\n  const explicitPrivacy = jsdoc.getPrivacy(annotation);\n  const specificName = name.slice(name.lastIndexOf('.') + 1);\n\n  if (explicitPrivacy) {\n    return explicitPrivacy;\n  }\n  if (specificName.startsWith('__')) {\n    return 'private';\n  } else if (specificName.startsWith('_')) {\n    return 'protected';\n  } else if (specificName.endsWith('_')) {\n    return 'private';\n  } else if (configurationProperties.has(specificName)) {\n    return 'protected';\n  }\n  return defaultPrivacy;\n}\n\n/**\n * Properties on element prototypes that are part of the custom elment lifecycle\n * or Polymer configuration syntax.\n *\n * TODO(rictic): only treat the Polymer ones as private when dealing with\n *   Polymer.\n */\nexport const configurationProperties: ImmutableSet<string> = new Set([\n  'attached',\n  'attributeChanged',\n  'beforeRegister',\n  'configure',\n  'constructor',\n  'created',\n  'detached',\n  'enableCustomStyleProperties',\n  'extends',\n  'hostAttributes',\n  'is',\n  'listeners',\n  'mixins',\n  'observers',\n  'properties',\n  'ready',\n  'registered',\n]);\n\n/**\n * Scan any methods on the given node, if it's a class expression/declaration.\n */\nexport function getMethods(node: estree.Node, document: JavaScriptDocument):\n    Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const statement of _getMethods(node)) {\n    if (statement.static === false) {\n      const method = toScannedMethod(\n          statement, document.sourceRangeForNode(statement)!, document);\n      docs.annotate(method);\n      methods.set(method.name, method);\n    }\n  }\n  return methods;\n}\n\n/**\n * Scan any static methods on the given node, if it's a class\n * expression/declaration.\n */\nexport function getStaticMethods(\n    node: estree.Node,\n    document: JavaScriptDocument): Map<string, ScannedMethod> {\n  const methods = new Map<string, ScannedMethod>();\n  for (const method of _getMethods(node)) {\n    if (method.static === true) {\n      const scannedMethod = toScannedMethod(\n          method, document.sourceRangeForNode(method)!, document);\n      docs.annotate(scannedMethod);\n      methods.set(scannedMethod.name, scannedMethod);\n    }\n  }\n  return methods;\n}\n\nfunction* _getMethods(node: estree.Node) {\n  if (node.type !== 'ClassDeclaration' && node.type !== 'ClassExpression') {\n    return;\n  }\n  for (const statement of node.body.body) {\n    if (statement.type === 'MethodDefinition' && statement.kind === 'method') {\n      yield statement;\n    }\n  }\n}\n"]}