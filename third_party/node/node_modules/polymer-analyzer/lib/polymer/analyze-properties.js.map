{"version":3,"sources":["polymer/analyze-properties.ts"],"names":[],"mappings":"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","file":"analyze-properties.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport * as doctrine from 'doctrine';\nimport * as estree from 'estree';\n\nimport * as astValue from '../javascript/ast-value';\nimport * as esutil from '../javascript/esutil';\nimport {JavaScriptDocument} from '../javascript/javascript-document';\nimport * as jsdoc from '../javascript/jsdoc';\nimport {Severity, Warning} from '../model/model';\n\nimport {parseExpressionInJsStringLiteral} from './expression-scanner';\nimport {toScannedPolymerProperty} from './js-utils';\nimport {ScannedPolymerProperty} from './polymer-element';\n\n/**\n * Given a properties block (i.e. object literal), parses and extracts the\n * properties declared therein.\n *\n * @param node The value of the `properties` key in a Polymer 1 declaration, or\n *     the return value of the `properties` static getter in a Polymer 2 class.\n * @param document The containing JS document.\n */\nexport function analyzeProperties(\n    node: estree.Node, document: JavaScriptDocument): ScannedPolymerProperty[] {\n  const analyzedProps: ScannedPolymerProperty[] = [];\n\n  if (node.type !== 'ObjectExpression') {\n    return analyzedProps;\n  }\n\n  for (const property of node.properties) {\n    const prop = toScannedPolymerProperty(\n        property, document.sourceRangeForNode(property)!, document);\n\n    // toScannedPolymerProperty does the wrong thing for us with type. We want\n    // type to be undefined unless there's a positive signal for the type.\n    // toScannedPolymerProperty will give Object because it infers based on the\n    // property declaration.\n    prop.type = undefined;\n    const typeTag = jsdoc.getTag(prop.jsdoc, 'type');\n    if (typeTag) {\n      prop.type =\n          typeTag.type ? doctrine.type.stringify(typeTag.type) : undefined;\n    }\n    prop.published = true;\n\n    let isComputed = false;\n\n    if (property.value.type === 'Identifier') {\n      // If we've already got a type it's from jsdoc and thus canonical.\n      if (!prop.type) {\n        prop.type = property.value.name;\n      }\n    } else if (property.value.type !== 'ObjectExpression') {\n      continue;\n    } else {\n      /**\n       * Parse the expression inside a property object block. e.g.\n       * property: {\n       *   key: {\n       *     type: String,\n       *     notify: true,\n       *     value: -1,\n       *     readOnly: true,\n       *     reflectToAttribute: true\n       *   }\n       * }\n       */\n      for (const propertyArg of property.value.properties) {\n        const propertyKey = esutil.objectKeyToString(propertyArg.key);\n\n        switch (propertyKey) {\n          case 'type':\n            // If we've already got a type, then it was found in the jsdocs,\n            // and is canonical.\n            if (!prop.type) {\n              prop.type = esutil.objectKeyToString(propertyArg.value);\n              if (prop.type === undefined) {\n                prop.warnings.push(new Warning({\n                  code: 'invalid-property-type',\n                  message: 'Invalid type in property object.',\n                  severity: Severity.WARNING,\n                  sourceRange: document.sourceRangeForNode(propertyArg)!,\n                  parsedDocument: document\n                }));\n              }\n            }\n            break;\n          case 'notify':\n            prop.notify = !!astValue.expressionToValue(propertyArg.value);\n            break;\n          case 'observer':\n            const val = astValue.expressionToValue(propertyArg.value);\n            prop.observerNode = propertyArg.value;\n            const parseResult = parseExpressionInJsStringLiteral(\n                document, propertyArg.value, 'identifierOnly');\n            prop.warnings.push(...parseResult.warnings);\n            prop.observerExpression = parseResult.databinding;\n            if (val === undefined) {\n              prop.observer = astValue.CANT_CONVERT;\n            } else {\n              prop.observer = JSON.stringify(val);\n            }\n            break;\n          case 'readOnly':\n            prop.readOnly = !!astValue.expressionToValue(propertyArg.value);\n            break;\n          case 'reflectToAttribute':\n            prop.reflectToAttribute = !!astValue.expressionToValue(propertyArg);\n            break;\n          case 'computed':\n            isComputed = true;\n            const computedParseResult = parseExpressionInJsStringLiteral(\n                document, propertyArg.value, 'callExpression');\n            prop.warnings.push(...computedParseResult.warnings);\n            prop.computedExpression = computedParseResult.databinding;\n            break;\n          case 'value':\n            prop.default =\n                JSON.stringify(astValue.expressionToValue(propertyArg.value));\n            break;\n          default:\n            break;\n        }\n      }\n    }\n\n    if (isComputed) {\n      prop.readOnly = true;\n    }\n\n    prop.type = esutil.CLOSURE_CONSTRUCTOR_MAP.get(prop.type!) || prop.type;\n\n    if (!prop.type) {\n      prop.warnings.push(new Warning({\n        code: 'no-type-for-property',\n        message: 'Unable to determine type for property.',\n        severity: Severity.WARNING,\n        sourceRange: document.sourceRangeForNode(property)!,\n        parsedDocument: document\n\n      }));\n    }\n\n    analyzedProps.push(prop);\n  }\n  return analyzedProps;\n};\n"]}