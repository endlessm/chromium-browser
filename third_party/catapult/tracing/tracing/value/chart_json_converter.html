<!DOCTYPE html>
<!--
Copyright 2016 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->

<link rel="import" href="/tracing/value/histogram.html">
<link rel="import" href="/tracing/value/legacy_unit_info.html">

<script>
'use strict';
tr.exportTo('tr.v', function() {
  class ChartJsonConverter {
    /**
     * Parses Values from |charts|, converts them to Histograms, and adds those
     * to |histograms|.
     *
     * @param {!Array.<!Object>} charts
     * @param {!tr.v.HistogramSet} histograms
     */
    static convertChartJson(charts, histograms) {
      for (const [name, pageValues] of Object.entries(charts.charts)) {
        if (name === 'trace') continue;

        const pageValuesCount = Object.keys(pageValues).length;
        for (const [storyName, value] of Object.entries(pageValues)) {
          if (pageValuesCount > 1 && storyName === 'summary') continue;

          const unitInfo = tr.v.LEGACY_UNIT_INFO.get(value.units) || {};
          const unitName = unitInfo.name || 'unitlessNumber';
          const conversionFactor = unitInfo.conversionFactor || 1;

          let improvementDirection = tr.b.ImprovementDirection.DONT_CARE;
          if (unitInfo.defaultImprovementDirection !== undefined) {
            improvementDirection = unitInfo.defaultImprovementDirection;
          }
          // Metrics have the final say.
          if (value.improvement_direction !== undefined) {
            improvementDirection =
              ChartJsonConverter.convertImprovementDirection(
                  value.improvement_direction);
          }
          const unitNameSuffix = tr.b.Unit.nameSuffixForImprovementDirection(
              improvementDirection);

          const hist = new tr.v.Histogram(
              value.name,
              tr.b.Unit.byName[unitName + unitNameSuffix],
              tr.v.HistogramBinBoundaries.SINGULAR);
          hist.description = value.description || '';
          histograms.addHistogram(hist);

          if (pageValuesCount > 1) {
            hist.diagnostics.set(tr.v.d.RESERVED_NAMES.STORIES,
                new tr.v.d.GenericSet([storyName]));
          }

          if (value.tir_label) {
            hist.diagnostics.set(
                tr.v.d.RESERVED_NAMES.STORY_TAGS,
                new tr.v.d.GenericSet([`tir_label:${value.tir_label}`]));
          }

          if (charts.benchmark_name) {
            hist.diagnostics.set(
                tr.v.d.RESERVED_NAMES.BENCHMARKS,
                new tr.v.d.GenericSet([charts.benchmark_name]));
          }

          if (charts.label) {
            hist.diagnostics.set(
                tr.v.d.RESERVED_NAMES.LABELS,
                new tr.v.d.GenericSet([charts.label]));
          }

          if (charts.benchmarkStartMs) {
            hist.diagnostics.set(
                tr.v.d.RESERVED_NAMES.BENCHMARK_START,
                new tr.v.d.DateRange(charts.benchmarkStartMs));
          }

          if (value.type === 'histogram') {
            for (const bucket of value.buckets) {
              // Take the center of the bin. This coarse granularity can amplify
              // noise when a measurement moves from one bin to the next.
              const sample = conversionFactor * (bucket.high + bucket.low) / 2;
              for (let i = 0; i < bucket.count; ++i) {
                hist.addSample(sample);
              }
            }
          } else if (value.type === 'list_of_scalar_values') {
            // |value.values| is undefined if the list_of_scalar_values is
            // empty.
            if (value.values) {
              for (const sample of value.values) {
                hist.addSample(sample * conversionFactor);
              }
            }
          } else if (value.type === 'scalar') {
            hist.addSample(value.value * conversionFactor);
          }
        }
      }
    }

    static convertImprovementDirection(improvementDirection) {
      switch (improvementDirection) {
        case 'down': return tr.b.ImprovementDirection.SMALLER_IS_BETTER;
        case 'up': return tr.b.ImprovementDirection.BIGGER_IS_BETTER;
        default: return tr.b.ImprovementDirection.DONT_CARE;
      }
    }
  }

  return {
    ChartJsonConverter,
  };
});
</script>
